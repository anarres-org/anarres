---

- name: Initial tasks
  hosts: all
  become: true
  gather_facts: false
  tasks:
    - name: Create data directory
      file:
        path: "{{ data_path }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
  tags: init

- name: Deploy common
  hosts: all
  become: true
  gather_facts: false
  roles:
    - role: anarres-common
  tags: common

- name: Deploy sec
  hosts: all
  become: true
  gather_facts: false
  roles:
    - role: anarres-sec
  tags: sec

- name: Deploy web related services
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ base_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
    letsencrypt_method: standalone
  pre_tasks:
    - name: Gather tasks
      setup:
        filter: ansible_*

    - name: Add group name ssl-cert for SSL certificates
      group:
        name: ssl-cert
        state: present

    - name: Install certbot package
      package:
        name: certbot
        state: present
      retries: 3
      delay: 3
      register: install_certbot
      until: install_certbot is succeeded
      tags: letsencrypt

    - name: Create live directory for Let's Encrypt
      file:
        state: directory
        path: "/etc/letsencrypt/live"
        group: ssl-cert
        owner: root
      tags: letsencrypt

    - name: Create web directory
      file:
        path: "{{ web_path_letsencrypt }}"
        state: directory
        owner: www-data
        group: www-data
        mode: "u=rwx,g=r,o="
  post_tasks:
    - name: Add iptables rules for HTTP and HTTPS
      iptables_raw:
        name: web_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ web_ports_http | default('80') }} -j ACCEPT
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ web_ports_https | default('443') }} -j ACCEPT
      tags: iptables
  roles:
    - role: letsencrypt-request
      tags:
        - base_cert
        - letsencrypt_request
        - letsencrypt
    - role: anarres-nginx
      tags: nginx
  tags:
    - web-base
    - web

## OpenLDAP

- name: Get openldap subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ openldap_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service docker.openldap restart
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: openldap

- name: Deploy openldap in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    enable_db: false
    create_network: true
    service_name: openldap
    docker_image: "{{ openldap_docker_image }}"
    container_certs_path: /container/service/slapd/assets/certs
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v {{ openldap_directory.data }}:/var/lib/ldap \
      -v {{ openldap_directory.conf }}:/etc/ldap/slapd.d \
      -v /etc/letsencrypt/live/{{ openldap_domain }}:{{ container_certs_path }}/live/{{ openldap_domain }}/:ro \
      -v /etc/letsencrypt/archive/{{ openldap_domain }}:{{ container_certs_path }}/archive/{{ openldap_domain }}/:ro \
      -p {{ openldap_port_secure }}:636 \
      -e LDAP_ORGANISATION="{{ openldap_domain }}" \
      -e LDAP_DOMAIN="{{ openldap_domain }}" \
      -e LDAP_ADMIN_PASSWORD="{{ openldap_admin_password }}" \
      -e LDAP_BASE_DN="{{ openldap_base_DN }}" \
      -e LDAP_READONLY_USER=true \
      -e LDAP_READONLY_USER_USERNAME=readonly \
      -e LDAP_READONLY_USER_PASSWORD="{{ openldap_readonly_password }}" \
      -e LDAP_TLS="true" \
      -e LDAP_TLS_VERIFY_CLIENT="try" \
      -e LDAP_TLS_CRT_FILENAME="live/{{ openldap_domain }}/cert.pem" \
      -e LDAP_TLS_KEY_FILENAME="live/{{ openldap_domain }}/privkey.pem" \
      -e LDAP_TLS_CA_CRT_FILENAME="live/{{ openldap_domain }}/fullchain.pem" \
      -e LDAP_NOFILE=1024 \
      --network {{ service_name }} \
      {{ docker_image }} --copy-service
  pre_tasks:
    - name: Create openldap directories
      file:
        path: "{{ item.value }}"
        state: directory
        mode: 0700
      with_dict: "{{ openldap_directory }}"
  post_tasks:
    - name: Add iptables rules for OpenLDAP
      become: true
      iptables_raw:
        name: openldap_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ openldap_port_secure }} -j ACCEPT
      tags: iptables

    - name: Install requiered python LDAP module
      package:
        name: python-ldap
        state: present
      tags: dependencies

    - name: Wait for configuration database container to start
      wait_for:
        port: "{{ openldap_port_secure }}"

    - name: Add groups organizational unit
      ldap_entry:
        dn: "ou=groups,{{ openldap_base_DN }}"
        objectClass: organizationalUnit
        server_uri: "{{ openldap_server_uri }}"
        start_tls: false
        validate_certs: "{{ testing is undefined and openldap_validate_certs }}"
        bind_dn: "cn=admin,{{ openldap_base_DN }}"
        bind_pw: "{{ openldap_admin_password }}"
      tags:
        - ldap-setup

    - name: Add users organizational unit
      ldap_entry:
        dn: "ou=users,{{ openldap_base_DN }}"
        objectClass: organizationalUnit
        server_uri: "{{ openldap_server_uri }}"
        start_tls: false
        validate_certs: "{{ testing is undefined and openldap_validate_certs }}"
        bind_dn: "cn=admin,{{ openldap_base_DN }}"
        bind_pw: "{{ openldap_admin_password }}"
      tags:
        - ldap-setup

    - name: Add users group
      ldap_entry:
        dn: "cn=users,ou=groups,{{ openldap_base_DN }}"
        objectClass: posixGroup
        attributes:
          gidNumber: 2000
        server_uri: "{{ openldap_server_uri }}"
        start_tls: false
        validate_certs: "{{ testing is undefined and openldap_validate_certs }}"
        bind_dn: "cn=admin,{{ openldap_base_DN }}"
        bind_pw: "{{ openldap_admin_password }}"
      tags:
        - ldap-setup
  roles:
    - role: generic_docker_systemd
  tags: openldap

## phpLDAPadmin

- name: Deploy phpldapadmin in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    enable_db: false
    service_name: phpldapadmin
    docker_image: "{{ phpldapadmin_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -p {{ phpldapadmin_internal_web_port }}:80 \
      -e  PHPLDAPADMIN_LDAP_HOSTS="{{ phpldapadmin_ldap_hosts }}" \
      -e PHPLDAPADMIN_HTTPS="false" \
      -e PHPLDAPADMIN_LDAP_CLIENT_TLS_REQCERT="allow" \
      --network openldap \
      {{ docker_image }}
  roles:
    - role: generic_docker_systemd
  tags: phpldapadmin

- name: Get phpldapadmin subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ phpldapadmin_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: phpldapadmin

- name: Configure nginx proxy for phpldapadmin
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ phpldapadmin_domain }}"
    binded_port: "{{ phpldapadmin_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: phpldapadmin

## Gitea

- name: Deploy gitea in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: gitea
    docker_image: "{{ gitea_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ gitea_directory.data }}":/data \
      -p "{{ gitea_ssh_port }}:22" -p "{{ gitea_internal_web_port }}:3000" \
      -e "USER_UID=1000" -e "USER_GID=1000" \
      --network "{{ gitea_network }}" \
      "{{ docker_image }}"
    service_db_name: "{{ gitea_db_service_name }}"
    db_name: "{{ gitea_db_name }}"
    db_user: "{{ gitea_db_user }}"
    db_user_pass: "{{ gitea_db_user_pass }}"
  pre_tasks:
    - name: Create gitea directories 755
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0755
      with_items:
        - "{{ gitea_directory.data }}"
        - "{{ gitea_directory.conf }}"
        - "{{ gitea_directory.git_data }}"

    - name: Create gitea directories 700
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_items:
        - "{{ gitea_directory.ssh_data }}"

    - name: Configure gitea
      template:
        src: gitea-app.ini.j2
        dest: "{{ gitea_directory.data }}/gitea/conf/app.ini"
        force: "{{ override | default('no') }}"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0644
  post_tasks:
    - name: Add iptables rules for gitea
      become: true
      iptables_raw:
        name: gitea_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ gitea_ssh_port | default('2222') }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: gitea

- name: Get gitea subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ gitea_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: gitea

- name: Configure nginx proxy for gitea
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ gitea_domain }}"
    binded_port: "{{ gitea_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: gitea

## CodiMD

- name: Deploy codimd in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: codimd
    docker_image: "{{ codimd_docker_image }}"
    docker_db_image: "{{ codimd_db_image }}"
    create_network: true
    db_type: postgres
    docker_service_directory_db: "{{ codimd_directory.db }}"
    db_user_pass: "{{ codimd_db_user_pass }}"
    db_config_port: 5432
    db_name: "{{ codimd_db_name }}"
    db_user: "{{ codimd_db_user }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -p "{{ codimd_web_port }}:3000" \
      -e "USER_UID=1000" -e "USER_GID=1000" \
      -e "CMD_DOMAIN={{ codimd_domain }}" \
      -e "CMD_DB_URL=postgres://{{ codimd_db_user }}:{{ codimd_db_user_pass }}@{{ codimd_db_service_name }}:5432/{{ codimd_db_name }}" \
      -e "CMD_URL_ADDPORT=false" \
      {% if codimd_enable_ldap %}
      -e "CMD_LDAP_URL={{ codimd_ldap_url }}" \
      -e "CMD_LDAP_BINDDN={{ codimd_ldap_binddn }}" \
      -e "CMD_LDAP_BINDCREDENTIALS={{ codimd_ldap_bindcredentials }}" \
      -e "CMD_LDAP_SEARCHBASE={{ codimd_ldap_searchbase }}" \
      -e "CMD_LDAP_SEARCHFILTER={{ codimd_ldap_searchfilter }}" \
      -e "CMD_LDAP_SEARCHATTRIBUTES={{ codimd_ldap_searchattributes }}" \
      -e "CMD_LDAP_USERIDFIELD={{ codimd_ldap_userfield }}" \
      -e "CMD_LDAP_USERNAMEFIELD={{ codimd_ldap_usernamefield }}" \
      -e 'CMD_IMAGE_UPLOAD_TYPE=filesystem' \
      -e "CMD_LDAP_TLS_CA=/etc/ssl/certs/ca-certificates.crt" \
      -v "{{ ca_certs_path }}:/etc/ssl/certs/ca-certificates.crt:ro" \
      -v "{{ codimd_directory.uploads }}:/codimd/public/uploads/" \
      {% endif %}
      --network "{{ codimd_network_name }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create codimd directories
      file:
        path: "{{ item.value }}"
        state: directory
        mode: 0700
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
      with_dict: "{{ codimd_directory }}"
  roles:
    - role: generic_docker_systemd
  tags: codimd

- name: Get codimd subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ codimd_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: codimd

- name: Configure nginx proxy for codimd
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ codimd_domain }}"
    binded_port: "{{ codimd_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: codimd

## Drone

- name: Deploy drone in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    enable_db: false
    service_name: drone
    docker_image: "{{ drone_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v /var/run/docker.sock:/var/run/docker.sock \
      -v "{{ drone_directory.data }}":/data \
      -p "{{ drone_internal_web_port }}:80" \
      -e "USER_UID=1000" -e "USER_GID=1000" \
      -e "DRONE_GITEA_SERVER=https://{{ gitea_domain }}" \
      -e "DRONE_GIT_ALWAYS_AUTH=false" \
      -e "DRONE_RUNNER_CAPACITY=2" \
      -e "DRONE_SERVER_HOST={{ drone_domain }}" \
      -e "DRONE_SERVER_PROTO=https" \
      -e "DRONE_TLS_AUTOCERT=false" \
      --network "{{ gitea_network }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create drone directories
      file:
        path: "{{ drone_directory.data }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
  roles:
    - role: generic_docker_systemd
  tags: drone

- name: Get drone subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ drone_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: drone

- name: Configure nginx proxy for drone
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ drone_domain }}"
    binded_port: "{{ drone_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: drone

## Drone for GitHub

- name: Deploy drone for github in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    enable_db: false
    service_name: drone_github
    docker_image: "{{ drone_github_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v /var/run/docker.sock:/var/run/docker.sock \
      -v "{{ drone_github_directory.data }}":/data \
      -p "{{ drone_github_internal_web_port }}:80" \
      -e "USER_UID=1000" -e "USER_GID=1000" \
      -e "DRONE_GITHUB_SERVER=https://github.com" \
      -e "DRONE_GITHUB_CLIENT_ID={{ drone_github_client_id }}" \
      -e "DRONE_GITHUB_CLIENT_SECRET={{ drone_github_client_secret }}" \
      -e "DRONE_RUNNER_CAPACITY=2" \
      -e "DRONE_SERVER_HOST={{ drone_github_domain }}" \
      -e "DRONE_SERVER_PROTO=https" \
      -e "DRONE_TLS_AUTOCERT=false" \
      --network "{{ gitea_network }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create drone_github directories
      file:
        path: "{{ drone_github_directory.data }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
  roles:
    - role: generic_docker_systemd
  tags: drone_github

- name: Get drone_github subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ drone_github_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: drone_github

- name: Configure nginx proxy for drone_github
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ drone_github_domain }}"
    binded_port: "{{ drone_github_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: drone_github

## Transmission

- name: Deploy transmission in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    enable_db: false
    service_name: transmission
    create_volume: false
    docker_image: "{{ transmission_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ transmission_directory.conf }}":/config \
      -v "{{ transmission_directory.downloads }}":/downloads \
      -v "{{ transmission_directory.watch }}":/watch \
      -e "PGID=1000" -e "PUID=1000" \
      -e "TZ={{ transmission_timezone }}" \
      -p "{{ transmission_internal_web_port }}:9091" \
      -p 51413:51413/tcp \
      -p 51413:51413/udp \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create transmission directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ transmission_directory }}"

    - name: Configure transmission
      template:
        src: transmission-settings.json.j2
        dest: "{{ transmission_directory.conf }}/settings.json"
        force: "{{ override | default('no') }}"
  post_tasks:
    - name: Add iptables rules for transmission
      iptables_raw:
        name: transmission_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ transmission_peer_port }} -j ACCEPT
          -A INPUT -p udp -m state --state NEW -m udp --dport {{ transmission_peer_port }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: transmission

- name: Get transmission subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ transmission_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: transmission

- name: Configure nginx proxy for transmission
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ transmission_domain }}"
    binded_port: "{{ transmission_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: transmission

## Wallabag

- name: Deploy wallabag in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: wallabag
    docker_image: "{{ wallabag_docker_image }}"
    create_user_and_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -p "{{ wallabag_internal_web_port }}:80" \
      -v "{{ wallabag_path_images }}":/var/www/wallabag/web/assets/images \
      --network "{{ service_name }}" \
      -e "MYSQL_ROOT_PASSWORD={{ db_pass }}" \
      -e "SYMFONY__ENV__DOMAIN_NAME=https://{{ wallabag_domain }}" \
      -e "SYMFONY__ENV__FOSUSER_CONFIRMATION=false" \
      -e "SYMFONY__ENV__DATABASE_DRIVER=pdo_mysql" \
      -e "SYMFONY__ENV__DATABASE_HOST={{ service_db_name }}" \
      -e "SYMFONY__ENV__DATABASE_PORT=3306" \
      -e "SYMFONY__ENV__DATABASE_NAME={{ wallabag_db_name }}" \
      -e "SYMFONY__ENV__DATABASE_USER={{ wallabag_db_user }}" \
      -e "SYMFONY__ENV__DATABASE_PASSWORD={{ wallabag_db_user_pass }}" \
      "{{ docker_image }}"
    service_db_name: "{{ wallabag_db_service_name }}"
    db_name: "{{ wallabag_db_name }}"
    db_user: "{{ wallabag_db_user }}"
    db_user_pass: "{{ wallabag_db_user_pass }}"
  pre_tasks:
    - name: Create wallabag images directory
      file:
        path: "{{ wallabag_path_images }}"
        state: directory
        owner: nobody
        group: nogroup
        mode: 0700
  roles:
    - role: generic_docker_systemd
  tags: wallabag

- name: Get wallabag subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ wallabag_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: wallabag

- name: Configure nginx proxy for wallabag
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ wallabag_domain }}"
    binded_port: "{{ wallabag_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: wallabag

## Selfoss

#  TODO: configuration template <06-07-18, m0wer>
#  TODO: external db <06-07-18, m0wer>

#
# - name: Prepare selfoss deployment
#   hosts: all
#   tasks:
#     - name: Create selfoss data directory
#       file:
#         path: "{{ selfoss_path_data }}"
#         state: directory
#         owner: "{{ user_uid_1000 }}"
#         group: "{{ group_gid_1000 }}"
#         mode: 0700
#   tags: selfoss
#
# - name: Deploy selfoss in docker
#   hosts: all
#   vars:
#     create_volume: false
#     service_name: selfoss
#     docker_image: "{{ selfoss_docker_image }}"
#     enable_db: false
#     docker_command: |
#       /usr/bin/docker run --rm --name "{{ service_name }}" \
#       -e GID=0 -e UID=0 \
#       -p "{{ selfoss_internal_web_port }}:8888" \
#       -v "{{ selfoss_path_data }}":/var/www/html/data \
#       "{{ docker_image }}"
#   roles:
#     - role: generic_docker_systemd
#   tags: selfoss
#
# - name: Get selfoss subdomain Let's Encrypt certificate
#   hosts: all
#   vars:
#     domain: "{{ selfoss_domain }}"
#     letsencrypt_renew_hook: /usr/sbin/service nginx reload
#   roles:
#     - role: letsencrypt-request
#      tags: letsecrypt_request
#   tags: selfoss
#
# - name: Configure nginx proxy for selfoss
#   hosts: all
#   vars:
#     domain: "{{ selfoss_domain }}"
#     binded_port: "{{ selfoss_internal_web_port }}"
#   roles:
#     - role: add_nginx_proxy_conf
#      tags: proxy
#   tags: selfoss

## Syncthing

- name: Deploy syncthing in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: syncthing
    docker_image: "{{ syncthing_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ syncthing_directory.conf }}":/var/syncthing/config \
      -v "{{ syncthing_directory.data }}":/var/syncthing \
      -p "{{ syncthing_internal_web_port }}:8384" \
      -p "{{ syncthing_listening_port }}:22000" \
      -p "{{ syncthing_discovery_port }}:21027/udp" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create syncthing directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ syncthing_directory }}"
  post_tasks:
    - name: Add iptables rules for syncthing
      iptables_raw:
        name: syncthing_rules
        weight: 20
        rules: |
          -A INPUT -p udp -m state --state NEW -m udp --dport {{ syncthing_discovery_port }} -j ACCEPT
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ syncthing_listening_port }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: syncthing

- name: Get syncthing subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ syncthing_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: syncthing

- name: Configure nginx proxy for syncthing
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ syncthing_domain }}"
    binded_port: "{{ syncthing_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: syncthing

## OpenVPN

- name: Deploy openvpn in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: openvpn
    docker_image: "{{ openvpn_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ openvpn_directory.conf }}":/etc/openvpn \
      --cap-add=NET_ADMIN \
      -p "{{ openvpn_port }}:1194/{{ openvpn_protocol }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create openvpn directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ openvpn_directory }}"
      notify: Configure openvpn container
  post_tasks:
    - name: Add iptables rules for openvpn
      iptables_raw:
        name: openvpn_rules
        weight: 20
        rules: |
          {{ openvpn_iptables_p2p_rule }}
      tags: iptables
  handlers:
    - name: Configure openvpn container
      command: "{{ openvpn_confiure_docker_command }}"
      notify: Create openvpn CA
      #  docker_container:
      #    image: "{{ openvpn_docker_image }}"
      #    name: openvpn-conf
      #    cleanup: true
      #    command: "ovpn_genconfig -u {{ openvpn_protocol }}://{{ openvpn_domain }}"
    - name: Create openvpn CA
      expect:
        command: "{{ openvpn_create_ca_command }}"
        timeout: 600
        responses:
          "Enter New CA Key Passphrase": "{{ openvpn_ca_pass }}"
          "Re-Enter New CA Key Passphrase": "{{ openvpn_ca_pass }}"
          "Common Name": "{{ openvpn_ca_CN }}"
          "Enter pass phrase for": "{{ openvpn_ca_pass }}"
  roles:
    - role: generic_docker_systemd
  tags: openvpn

## Radicale

- name: Deploy radicale in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: radicale
    docker_image: "{{ radicale_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -e UID=1000 -e GID=1000 \
      -p "127.0.0.1:5232:{{ radicale_internal_web_port }}" \
      --init \
      --pids-limit 50 \
      --security-opt="no-new-privileges:true" \
      --health-cmd="curl --fail http://localhost:5232 || exit 1" \
      --health-interval=30s \
      --health-retries=3 \
      -v "{{ radicale_directory.data }}":/data \
      -v "{{ radicale_directory.etc }}":/etc/radicale \
      -v "{{ radicale_directory.conf }}":/config:ro \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create radicale directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ radicale_directory }}"

    - name: Copy radicale configuration template
      template:
        src: radicale-config.j2
        dest: "{{ radicale_directory.conf }}/config"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700

    - name: Add radicale login credentiasl
      lineinfile:
        path: "{{ radicale_directory.etc }}/users"
        line: "{{ radicale_user }}:{{ radicale_pass }}"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
        create: true
  roles:
    - role: generic_docker_systemd
  tags: radicale

- name: Get radicale subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ radicale_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: radicale

- name: Configure nginx proxy for radicale
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ radicale_domain }}"
    binded_port: "{{ radicale_internal_web_port }}"
    proxy_conf: |
      proxy_pass        http://127.0.0.1:{{ binded_port }};
      proxy_set_header  X-Script-Name /;
      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_pass_header Authorization;
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: radicale

## taskd

- name: Deploy taskd in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    enable_db: false
    service_name: taskd
    docker_image: "{{ taskd_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ taskd_directory.data }}":/var/taskd \
      -p "{{ taskd_port }}:53589" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create taskd directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ taskd_directory }}"
  post_tasks:
    - name: Add iptables rules for taskd
      iptables_raw:
        name: taskd_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ taskd_port | default('53589') }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: taskd

## Nextcloud

- name: Deploy nextcloud in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: nextcloud
    docker_image: "{{ nextcloud_docker_image }}"
    create_volume: false
    service_db_name: "{{ nextcloud_db_service_name }}"
    db_name: "{{ nextcloud_db_name }}"
    db_user: "{{ nextcloud_db_user }}"
    db_user_pass: "{{ nextcloud_db_user_pass }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ nextcloud_directory.data }}":/var/www/html \
      -p "{{ nextcloud_internal_web_port }}:80" \
      -e "MYSQL_HOST={{ service_db_name }}" \
      -e "MYSQL_DATABASE={{ db_name }}" \
      -e "MYSQL_USER={{ db_user }}" \
      -e "MYSQL_PASSWORD={{ db_user_pass }}" \
      --network "{{ service_name }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create nextcloud directories
      become: true
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_33 }}"
        group: 0
        mode: 0750
      with_dict: "{{ nextcloud_directory }}"
  roles:
    - role: generic_docker_systemd
  tags: nextcloud

- name: Get nextcloud subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ nextcloud_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: nextcloud

- name: Configure nginx proxy for nextcloud
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ nextcloud_domain }}"
    binded_port: "{{ nextcloud_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: nextcloud

## Taiga

- name: Deploy taiga in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: taiga
    docker_image: "{{ taiga_docker_image }}"
    docker_db_image: "{{ taiga_db_image }}"
    create_network: true
    create_volume: false
    db_type: postgres
    docker_service_directory_db: "{{ taiga_directory.db }}"
    db_user_pass: "{{ taiga_db_user_pass }}"
    db_config_port: 5432
    db_name: "{{ taiga_db_name }}"
    db_user: "{{ taiga_db_user }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -p "{{ taiga_internal_web_port }}:80" \
      -e "TAIGA_HOSTNAME={{ taiga_domain }}" \
      -e 'TAIGA_SSL=true' \
      -e "TAIGA_SECRET_KEY={{ taiga_secret_key }}" \
      -e 'TAIGA_DB_HOST=taiga-db' \
      -e "TAIGA_DB_NAME={{ db_name }}" \
      -e "TAIGA_DB_USER={{ db_user }}" \
      -e "TAIGA_DB_PASSWORD={{ db_user_pass }}" \
      {% if taiga_enable_ldap %}
      -e 'LDAP_ENABLE=true' \
      -e "LDAP_SERVER={{ taiga_ldap_server }}" \
      -e "LDAP_PORT={{ taiga_ldap_port }}" \
      -e "LDAP_BIND_DN={{ taiga_ldap_binddn }}" \
      -e "LDAP_BIND_PASSWORD={{ taiga_ldap_bindcredentials }}" \
      -e "LDAP_SEARCH_BASE={{ taiga_ldap_searchbase }}" \
      -e "LDAP_SEARCH_PROPERTY={{ taiga_ldap_search_property }}" \
      -e "LDAP_EMAIL_PROPERTY={{ taiga_ldap_email_attribute }}" \
      -e "LDAP_FULL_NAME_PROPERTY={{ taiga_ldap_full_name_attribute }}" \
      -e "TAIGA_BACKEND_WEBHOOKS_ENABLED={{ taiga_backend_webhooks_enabled }}" \
      -v "{{ taiga_directory.media }}:/taiga.io/taiga-back/media" \
      {% endif %}
      --network "{{ service_name }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create taiga directories
      file:
        path: "{{ item.value }}"
        state: directory
        mode: 0700
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
      with_dict: "{{ taiga_directory }}"
  roles:
    - role: generic_docker_systemd
  tags: taiga

- name: Get taiga subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ taiga_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: taiga

- name: Configure nginx proxy for taiga
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ taiga_domain }}"
    binded_port: "{{ taiga_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: taiga

## NFS

- name: Deploy nfs in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: nfs
    docker_image: "{{ nfs_docker_image }}"
    enable_db: false
    create_network: false
    create_volume: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      --cap-add SYS_ADMIN \
      -v "{{ nfs_directory.conf }}/exports":/etc/exports:ro \
      {{ nfs_export_volumes }}-p "{{ nfs_port | default('2049') }}:2049" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create nfs directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ nfs_directory }}"

    - name: Create nfs user mount directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ nfs_user_mounts }}"
      when: nfs_user_mounts is defined

    - name: Create nfs configuration file
      file:
        path: "{{ nfs_directory.conf }}/exports"
        state: touch
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
        modification_time: "preserve"
        access_time: "preserve"

    - name: Configure nfs
      blockinfile:
        block: "{{ nfs_exports_conf }}"
        path: "{{ nfs_directory.conf }}/exports"

    - name: Load kernel modules for nfs
      become: true
      modprobe:
        name: "{{ item }}"
        state: present
      with_items:
        - nfs
        - nfsd

    - name: Load kernel modules for nfs at boot
      become: true
      lineinfile:
        path: /etc/modules
        state: present
        line: "{{ item }}"
      with_items:
        - nfs
        - nfsd
  post_tasks:
    - name: Add iptables rules for nfs
      become: true
      iptables_raw:
        name: nfs_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ nfs_port | default('2049') }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: nfs

## BIND DNS Server

- name: Deploy bind_dns_server in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    enable_db: false
    create_network: true
    service_name: bind_dns_server
    docker_image: "{{ bind_dns_server_docker_image }}"
    container_certs_path: /container/service/slapd/assets/certs
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v {{ bind_dns_server_directory.data }}:/data \
      -p {{ bind_dns_server_port }}:53/tcp \
      -p {{ bind_dns_server_port }}:53/udp \
      -e WEBMIN_ENABLED=false \
      --network {{ service_name }} \
      {{ docker_image }}
  pre_tasks:
    - name: Create bind_dns_server directories
      file:
        path: "{{ item.value }}"
        owner: "{{ user_uid_101 }}"
        state: directory
        mode: 0700
      with_dict: "{{ bind_dns_server_directory }}"
  post_tasks:
    - name: Add iptables rules for BIND DNS server
      become: true
      iptables_raw:
        name: bind_dns_server_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ bind_dns_server_port }} -j ACCEPT
          -A INPUT -p udp -m state --state NEW -m udp --dport {{ bind_dns_server_port }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: bind_dns_server

## Murmur

- name: Get murmur subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ murmur_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service docker.murmur.service restart
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: murmur

- name: Deploy murmur in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: murmur
    docker_image: "{{ murmur_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -e 'PUID=1000' -e 'PGID=1000' \
      -e 'RUN_CHOWN=false' \
      -e "CERTDIR=/etc/letsencrypt/live/{{ murmur_domain }}" \
      -v "{{ murmur_directory.conf }}":/opt/murmur/config \
      -v "{{ murmur_directory.data }}":/opt/murmur/data \
      -v "{{ murmur_directory.log }}":/opt/murmur/log \
      -v '/etc/localtime:/etc/localtime:ro' \
      -v /etc/letsencrypt/live/{{ murmur_domain }}:/etc/letsencrypt/live/{{ murmur_domain }}/:ro \
      -v /etc/letsencrypt/archive/{{ murmur_domain }}:/etc/letsencrypt/archive/{{ murmur_domain }}/:ro \
      -p "{{ murmur_port }}:64738/tcp" \
      -p "{{ murmur_port }}:64738/udp" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create murmur directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ murmur_directory }}"
  post_tasks:
    - name: Add iptables rules for murmur
      iptables_raw:
        name: murmur_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ murmur_port }} -j ACCEPT
          -A INPUT -p udp -m state --state NEW -m udp --dport {{ murmur_port }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: murmur

## Wiki.js

- name: Deploy wikijs in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: wikijs
    docker_image: "{{ wikijs_docker_image }}"
    docker_db_image: "{{ wikijs_db_image }}"
    create_network: true
    db_type: mongo
    docker_service_directory_db: "{{ wikijs_directory.db }}"
    db_user_pass: "{{ wikijs_db_user_pass }}"
    db_config_port: 5432
    db_name: "{{ wikijs_db_name }}"
    db_user: "{{ wikijs_db_user }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -p "{{ wikijs_web_port }}:3000" \
      -e "WIKI_ADMIN_EMAIL={{ wikijs_admin_email }}" \
      -v "{{ wikijs_directory.conf }}/config.yml:/var/wiki/config.yml:ro" \
      --network "{{ wikijs_network_name }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create wikijs directories
      file:
        path: "{{ item.value }}"
        state: directory
        mode: 0700
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
      with_dict: "{{ wikijs_directory }}"
    - name: Configure wikijs
      template:
        src: wikijs-conf.j2
        dest: "{{ wikijs_directory.conf }}/config.yml"
        force: "{{ override | default('no') }}"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
  roles:
    - role: generic_docker_systemd
  tags: wikijs

- name: Get wikijs subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ wikijs_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: wikijs

- name: Configure nginx proxy for wikijs
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ wikijs_domain }}"
    binded_port: "{{ wikijs_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: wikijs
