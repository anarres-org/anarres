---

- name: Initial tasks
  hosts: all
  become: true
  tasks:
    - name: Create data directory
      file:
        path: "{{ data_path }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
  tags: init

- name: Deploy common
  hosts: all
  become: true
  roles:
    - role: anarres-common
  tags: common

- name: Deploy sec
  hosts: all
  become: true
  roles:
    - role: anarres-sec
  tags: sec

- name: Setup requiered web iptables rules
  hosts: all
  become: true
  tasks:
    - name: Add iptables rules for HTTP and HTTPS
      iptables_raw:
        name: web_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ web_ports_http | default('80') }} -j ACCEPT
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ web_ports_https | default('443') }} -j ACCEPT
  tags:
    - iptables
    - web-iptables
    - web

- name: "[Pretask] Prepare web deployment"
  hosts: all
  become: true
  gather_facts: true
  tags:
    - web-prepare
    - web
  tasks:
    - name: Add group name ssl-cert for SSL certificates
      group:
        name: ssl-cert
        state: present

    - name: Install certbot package
      package:
        name: certbot
        state: present
      tags: letsencrypt

    - name: Create live directory for Let's Encrypt
      file:
        state: directory
        path: "/etc/letsencrypt/live"
        group: ssl-cert
        owner: root
      tags: letsencrypt

    - name: Create letsencrypt renew cronjob
      cron:
        name: letsencrypt auto renewal
        job: /usr/bin/certbot renew --quiet
        special_time: daily

    - name: Create web directory
      file:
        path: "{{ web_path_letsencrypt }}"
        state: directory
        owner: www-data
        group: www-data
        mode: "u=rwx,g=r,o="

- name: Deploy web related services
  hosts: all
  become: true
  gather_facts: true
  roles:
    - role: letsencrypt-request
      letsencrypt_renew_hook: /usr/sbin/service nginx reload
      letsencrypt_method: standalone
      tags:
        - base_cert
        - letsencrypt_request
    - role: anarres-nginx
      tags: nginx
  vars:
    domain: "{{ base_domain }}"
  tags:
    - web-base
    - web

## Gitea

- name: Prepare gitea deployment
  hosts: all
  tasks:
    - name: Add iptables rules for gitea
      become: true
      iptables_raw:
        name: gitea_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ gitea_ssh_port | default('2222') }} -j ACCEPT
      tags: iptables

    - name: Create gitea directories
      become: true
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ gitea_directory }}"

    - name: Configure gitea
      template:
        src: gitea-app.ini.j2
        dest: "{{ gitea_directory.data }}/gitea/conf/app.ini"
        force: "{{ override | default('no') }}"
  tags: gitea

- name: Deploy gitea in docker
  hosts: all
  become: true
  vars:
    service_name: gitea
    docker_image: "{{ gitea_docker_image }}"
    create_volume: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ gitea_directory.data }}":/data \
      -p "{{ gitea_ssh_port }}:22" -p "{{ gitea_internal_web_port }}:3000" \
      -e "USER_UID=1000" -e "USER_GID=1000" \
      --network "{{ service_name }}" \
      "{{ docker_image }}"
    service_db_name: "{{ gitea_db_service_name }}"
    db_name: "{{ gitea_db_name }}"
    db_user: "{{ gitea_db_user }}"
    db_user_pass: "{{ gitea_db_user_pass }}"
  roles:
    - role: generic_docker_systemd
  tags: gitea

- name: Get gitea subdomain Let's Encrypt certificate
  hosts: all
  become: true
  vars:
    domain: "{{ gitea_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: gitea

- name: Configure nginx proxy for gitea
  hosts: all
  become: true
  vars:
    domain: "{{ gitea_domain }}"
    binded_port: "{{ gitea_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: gitea

## Transmission

- name: Prepare transmission deployment
  hosts: all
  tasks:
    - name: Create transmission directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ transmission_directory }}"

    - name: Configure transmission
      template:
        src: transmission-settings.json.j2
        dest: "{{ transmission_directory.conf }}/settings.json"
        force: "{{ override | default('no') }}"
  tags: transmission

- name: Setup requiered transmission iptables rules
  hosts: all
  become: true
  tasks:
    - name: Add iptables rules for transmission
      iptables_raw:
        name: transmission_rules
        weight: 20
        rules: |
          -A INPUT -p udp -m state --state NEW -m udp --dport {{ transmission_peer_port | default('51413') }} -j ACCEPT
      tags: iptables
  tags: transmission

- name: Deploy transmission in docker
  hosts: all
  become: true
  vars:
    enable_db: false
    service_name: transmission
    create_volume: false
    docker_image: "{{ transmission_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ transmission_directory.conf }}":/config \
      -v "{{ transmission_directory.downloads }}":/downloads \
      -v "{{ transmission_directory.watch }}":/watch \
      -e "PGID=1000" -e "PUID=1000" \
      -e "TZ={{ transmission_timezone }}" \
      -p "{{ transmission_internal_web_port }}:9091" -p 51413:51413 \
      -p 51413:51413/udp \
      "{{ docker_image }}"
  roles:
    - role: generic_docker_systemd
  tags: transmission

- name: Get transmission subdomain Let's Encrypt certificate
  hosts: all
  become: true
  vars:
    domain: "{{ transmission_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: transmission

- name: Configure nginx proxy for transmission
  hosts: all
  become: true
  vars:
    domain: "{{ transmission_domain }}"
    binded_port: "{{ transmission_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: transmission

## Wallabag

- name: Prepare wallabag deployment
  hosts: all
  become: true
  tasks:
    - name: Create wallabag images directory
      file:
        path: "{{ wallabag_path_images }}"
        state: directory
        owner: nobody
        group: nogroup
        mode: 0700
  tags: wallabag

- name: Deploy wallabag in docker
  hosts: all
  become: true
  vars:
    create_volume: false
    service_name: wallabag
    docker_image: "{{ wallabag_docker_image }}"
    create_user_and_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -p "{{ wallabag_internal_web_port }}:80" \
      -v "{{ wallabag_path_images }}":/var/www/wallabag/web/assets/images \
      --network "{{ service_name }}" \
      -e "MYSQL_ROOT_PASSWORD={{ db_pass }}" \
      -e "SYMFONY__ENV__DOMAIN_NAME=https://{{ wallabag_domain }}" \
      -e "SYMFONY__ENV__FOSUSER_CONFIRMATION=false" \
      -e "SYMFONY__ENV__DATABASE_DRIVER=pdo_mysql" \
      -e "SYMFONY__ENV__DATABASE_HOST={{ service_db_name }}" \
      -e "SYMFONY__ENV__DATABASE_PORT=3306" \
      -e "SYMFONY__ENV__DATABASE_NAME={{ wallabag_db_name }}" \
      -e "SYMFONY__ENV__DATABASE_USER={{ wallabag_db_user }}" \
      -e "SYMFONY__ENV__DATABASE_PASSWORD={{ wallabag_db_user_pass }}" \
      "{{ docker_image }}"
    service_db_name: "{{ wallabag_db_service_name }}"
    db_name: "{{ wallabag_db_name }}"
    db_user: "{{ wallabag_db_user }}"
    db_user_pass: "{{ wallabag_db_user_pass }}"
  roles:
    - role: generic_docker_systemd
  tags: wallabag

- name: Get wallabag subdomain Let's Encrypt certificate
  hosts: all
  become: true
  vars:
    domain: "{{ wallabag_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: wallabag

- name: Configure nginx proxy for wallabag
  hosts: all
  become: true
  vars:
    domain: "{{ wallabag_domain }}"
    binded_port: "{{ wallabag_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: wallabag

## Selfoss

#  TODO: configuration template <06-07-18, m0u>
#  TODO: external db <06-07-18, m0u>

#
# - name: Prepare selfoss deployment
#   hosts: all
#   tasks:
#     - name: Create selfoss data directory
#       file:
#         path: "{{ selfoss_path_data }}"
#         state: directory
#         owner: "{{ user_uid_1000 }}"
#         group: "{{ group_gid_1000 }}"
#         mode: 0700
#   tags: selfoss
#
# - name: Deploy selfoss in docker
#   hosts: all
#   vars:
#     create_volume: false
#     service_name: selfoss
#     docker_image: "{{ selfoss_docker_image }}"
#     enable_db: false
#     docker_command: |
#       /usr/bin/docker run --rm --name "{{ service_name }}" \
#       -e GID=0 -e UID=0 \
#       -p "{{ selfoss_internal_web_port }}:8888" \
#       -v "{{ selfoss_path_data }}":/var/www/html/data \
#       "{{ docker_image }}"
#   roles:
#     - role: generic_docker_systemd
#   tags: selfoss
#
# - name: Get selfoss subdomain Let's Encrypt certificate
#   hosts: all
#   vars:
#     domain: "{{ selfoss_domain }}"
#     letsencrypt_renew_hook: /usr/sbin/service nginx reload
#   roles:
#     - role: letsencrypt-request
#      tags: letsecrypt_request
#   tags: selfoss
#
# - name: Configure nginx proxy for selfoss
#   hosts: all
#   vars:
#     domain: "{{ selfoss_domain }}"
#     binded_port: "{{ selfoss_internal_web_port }}"
#   roles:
#     - role: add_nginx_proxy_conf
#      tags: proxy
#   tags: selfoss

## Syncthing

- name: Prepare syncthing deployment
  hosts: all
  tasks:
    - name: Create syncthing directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ syncthing_directory }}"
  tags: syncthing

- name: Setup requiered syncthing iptables rules
  hosts: all
  become: true
  tasks:
    - name: Add iptables rules for syncthing
      iptables_raw:
        name: syncthing_rules
        weight: 20
        rules: |
          -A INPUT -p udp -m state --state NEW -m udp --dport {{ syncthing_discovery_port | default('21027') }} -j ACCEPT
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ syncthing_listening_port | default('22000') }} -j ACCEPT
      tags: iptables
  tags: syncthing

- name: Deploy syncthing in docker
  hosts: all
  become: true
  vars:
    create_volume: false
    service_name: syncthing
    docker_image: "{{ syncthing_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ syncthing_directory.conf }}":/var/syncthing/config \
      -v "{{ syncthing_directory.data }}":/var/syncthing \
      -p "{{ syncthing_internal_web_port }}:8384" \
      -p "{{ syncthing_listening_port }}:22000" \
      -p "{{ syncthing_discovery_port }}:21027/udp" \
      "{{ docker_image }}"
  roles:
    - role: generic_docker_systemd
  tags: syncthing

- name: Get syncthing subdomain Let's Encrypt certificate
  hosts: all
  become: true
  vars:
    domain: "{{ syncthing_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: syncthing

- name: Configure nginx proxy for syncthing
  hosts: all
  become: true
  vars:
    domain: "{{ syncthing_domain }}"
    binded_port: "{{ syncthing_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: syncthing

## OpenVPN

#  TODO: is this really needed? since the docker has full net capabilities <19-08-18, m0u>
- name: Setup requiered openvpn iptables rules
  hosts: all
  become: true
  tasks:
    - name: Add iptables rules for openvpn
      iptables_raw:
        name: openvpn_rules
        weight: 20
        rules: |
          -A INPUT -p {{ openvpn_protocol | default('udp') }} -m state --state NEW -m {{ openvpn_protocol | default('udp') }} --dport {{ openvpn_port | default('1194') }} -j ACCEPT
      tags: iptables
  tags: openvpn

- name: Prepare openvpn deployment
  hosts: all
  become: true
  vars:
    service_name: openvpn
  tasks:
    - name: Create openvpn directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ openvpn_directory }}"
      notify: Configure openvpn container

  handlers:
    - name: Configure openvpn container
      command: "  docker run -v {{ openvpn_directory.conf }}:/etc/openvpn --rm {{ openvpn_docker_image }} ovpn_genconfig -u {{ openvpn_protocol }}://{{ openvpn_domain }}"
      notify: Create openvpn CA
      #  docker_container:
      #    image: "{{ openvpn_docker_image }}"
      #    name: openvpn-conf
      #    cleanup: true
      #    command: "ovpn_genconfig -u {{ openvpn_protocol }}://{{ openvpn_domain }}"
    - name: Create openvpn CA
      expect:
        command: "docker run -v {{ openvpn_directory.conf }}:/etc/openvpn --rm -it {{ openvpn_docker_image}} ovpn_initpki"
        timeout: 600
        responses:
          "pass phrase": "{{ openvpn_ca_pass }}"
          "Common Name": "{{ openvpn_ca_CN }}"
  tags: openvpn

- name: Deploy openvpn in docker
  hosts: all
  become: true
  vars:
    create_volume: false
    service_name: openvpn
    docker_image: "{{ openvpn_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ openvpn_directory.conf }}":/etc/openvpn \
      --cap-add=NET_ADMIN \
      -p "{{ openvpn_port }}:1194/{{ openvpn_protocol }}" \
      "{{ docker_image }}"
  roles:
    - role: generic_docker_systemd
  tags: openvpn

## Radicale

- name: Prepare radicale deployment
  hosts: all
  tasks:
    - name: Create radicale directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ radicale_directory }}"
    - name: Copy radicale configuration template
      template:
        src: radicale-config.j2
        dest: "{{ radicale_directory.conf }}/config"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
    - name: Add radicale login credentiasl
      lineinfile:
        path: "{{ radicale_directory.etc }}/users"
        line: "{{ radicale_user }}:{{ radicale_pass }}"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
        create: true
  tags: radicale

- name: Deploy radicale in docker
  hosts: all
  become: true
  vars:
    create_volume: false
    service_name: radicale
    docker_image: "{{ radicale_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -e UID=1000 -e GID=1000 \
      -p "127.0.0.1:5232:{{ radicale_internal_web_port }}" \
      --init \
      --pids-limit 50 \
      --security-opt="no-new-privileges:true" \
      --health-cmd="curl --fail http://localhost:5232 || exit 1" \
      --health-interval=30s \
      --health-retries=3 \
      -v "{{ radicale_directory.data }}":/data \
      -v "{{ radicale_directory.etc }}":/etc/radicale \
      -v "{{ radicale_directory.conf }}":/config:ro \
      "{{ docker_image }}"
  roles:
    - role: generic_docker_systemd
  tags: radicale

- name: Get radicale subdomain Let's Encrypt certificate
  hosts: all
  become: true
  vars:
    domain: "{{ radicale_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: radicale

- name: Configure nginx proxy for radicale
  hosts: all
  become: true
  vars:
    domain: "{{ radicale_domain }}"
    binded_port: "{{ radicale_internal_web_port }}"
    proxy_conf: |
      proxy_pass        http://127.0.0.1:{{ binded_port }};
      proxy_set_header  X-Script-Name /;
      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_pass_header Authorization;
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: radicale

## taskd

- name: Prepare taskd deployment
  hosts: all
  tasks:
    - name: Create taskd directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ taskd_directory }}"
  tags: taskd

- name: Setup requiered taskd iptables rules
  hosts: all
  become: true
  tasks:
    - name: Add iptables rules for taskd
      iptables_raw:
        name: taskd_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ taskd_port | default('53589') }} -j ACCEPT
      tags: iptables
  tags: taskd

- name: Deploy taskd in docker
  hosts: all
  become: true
  vars:
    create_volume: false
    enable_db: false
    service_name: taskd
    docker_image: "{{ taskd_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ taskd_directory.data }}":/var/taskd \
      -p "{{ taskd_port }}:53589" \
      "{{ docker_image }}"
  roles:
    - role: generic_docker_systemd
  tags: taskd

## Nextcloud

- name: Prepare nextcloud deployment
  hosts: all
  tasks:
    - name: Create nextcloud directories
      become: true
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_33 }}"
        group: "{{ group_gid_33 }}"
        mode: 0770
      with_dict: "{{ nextcloud_directory }}"
  tags: nextcloud

- name: Deploy nextcloud in docker
  hosts: all
  become: true
  vars:
    service_name: nextcloud
    docker_image: "{{ nextcloud_docker_image }}"
    create_volume: false
    service_db_name: "{{ nextcloud_db_service_name }}"
    db_name: "{{ nextcloud_db_name }}"
    db_user: "{{ nextcloud_db_user }}"
    db_user_pass: "{{ nextcloud_db_user_pass }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ nextcloud_directory.data }}":/var/www/html \
      -p "{{ nextcloud_internal_web_port }}:80" \
      -e "MYSQL_HOST={{ service_db_name }}" \
      -e "MYSQL_DATABASE={{ db_name }}" \
      -e "MYSQL_USER={{ db_user }}" \
      -e "MYSQL_PASSWORD={{ db_user_pass }}" \
      --network "{{ service_name }}" \
      "{{ docker_image }}"
  roles:
    - role: generic_docker_systemd
  tags: nextcloud

- name: Get nextcloud subdomain Let's Encrypt certificate
  hosts: all
  become: true
  vars:
    domain: "{{ nextcloud_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: nextcloud

- name: Configure nginx proxy for nextcloud
  hosts: all
  become: true
  vars:
    domain: "{{ nextcloud_domain }}"
    binded_port: "{{ nextcloud_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: nextcloud

## NFS

- name: Prepare nfs deployment
  hosts: all
  tasks:
    - name: Create nfs directories
      become: true
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ nfs_directory }}"

    - name: Add iptables rules for nfs
      become: true
      iptables_raw:
        name: nfs_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ nfs_port | default('2049') }} -j ACCEPT
      tags: iptables
  tags: nfs

- name: Deploy nfs in docker
  hosts: all
  become: true
  vars:
    service_name: nfs
    docker_image: "{{ nfs_docker_image }}"
    enable_db: false
    create_network: false
    create_volume: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ nfs_directory.conf }}/exports":/etc/exports:ro \
      {{ nfs_export_volumes }}-p "{{ nfs_port | default('2049') }}:2049" \
      "{{ docker_image }}"
  roles:
    - role: generic_docker_systemd
  tags: nfs
