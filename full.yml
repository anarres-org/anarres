---

- name: Initial tasks
  hosts: all
  become: true
  gather_facts: false
  tasks:
    - name: Create data directory
      file:
        path: "{{ data_path }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
  tags: init

- name: Deploy common
  hosts: all
  become: true
  gather_facts: false
  roles:
    - role: anarres-common
  tags: common

- name: Deploy sec
  hosts: all
  become: true
  gather_facts: false
  roles:
    - role: anarres-sec
  tags: sec

- name: Deploy web related services
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ base_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
    letsencrypt_method: standalone
  pre_tasks:
    - name: Gather facts
      setup:
        filter: ansible_*

    - name: Add group name ssl-cert for SSL certificates
      group:
        name: ssl-cert
        state: present

    - name: Install certbot package
      package:
        name: certbot
        state: present
      retries: 3
      delay: 3
      register: install_certbot
      until: install_certbot is succeeded
      tags: letsencrypt

    - name: Create live directory for Let's Encrypt
      file:
        state: directory
        path: "/etc/letsencrypt/live"
        group: ssl-cert
        owner: root
      tags: letsencrypt

    - name: Create web directory
      file:
        path: "{{ web_path_letsencrypt }}"
        state: directory
        owner: www-data
        group: www-data
        mode: "u=rwx,g=r,o="
    - name: Add iptables rules for HTTP and HTTPS
      iptables_raw:
        name: web_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ web_ports_http | default('80') }} -j ACCEPT
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ web_ports_https | default('443') }} -j ACCEPT
      tags: iptables
  roles:
    - role: letsencrypt-request
      tags:
        - base_cert
        - letsencrypt_request
        - letsencrypt
    - role: anarres-nginx
      tags: nginx
  tags:
    - web-base
    - web

## OpenLDAP

- name: Get openldap subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ openldap_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service docker.openldap restart
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: openldap

- name: Deploy openldap in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    enable_db: false
    create_network: true
    service_name: openldap
    docker_image: "{{ openldap_docker_image }}"
    container_certs_path: /container/service/slapd/assets/certs
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v {{ openldap_directory.data }}:/var/lib/ldap \
      -v {{ openldap_directory.conf }}:/etc/ldap/slapd.d \
      -v /etc/letsencrypt/live/{{ openldap_domain }}:{{ container_certs_path }}/live/{{ openldap_domain }}/:ro \
      -v /etc/letsencrypt/archive/{{ openldap_domain }}:{{ container_certs_path }}/archive/{{ openldap_domain }}/:ro \
      -p {{ openldap_port_secure }}:636 \
      -e LDAP_ORGANISATION="{{ openldap_domain }}" \
      -e LDAP_DOMAIN="{{ openldap_domain }}" \
      -e LDAP_ADMIN_PASSWORD="{{ openldap_admin_password }}" \
      -e LDAP_BASE_DN="{{ openldap_base_DN }}" \
      -e LDAP_READONLY_USER=true \
      -e LDAP_READONLY_USER_USERNAME=readonly \
      -e LDAP_READONLY_USER_PASSWORD="{{ openldap_readonly_password }}" \
      -e LDAP_TLS="true" \
      -e LDAP_TLS_VERIFY_CLIENT="try" \
      -e LDAP_TLS_CRT_FILENAME="live/{{ openldap_domain }}/cert.pem" \
      -e LDAP_TLS_KEY_FILENAME="live/{{ openldap_domain }}/privkey.pem" \
      -e LDAP_TLS_CA_CRT_FILENAME="live/{{ openldap_domain }}/fullchain.pem" \
      -e LDAP_NOFILE=1024 \
      --network {{ service_name }} \
      {{ docker_image }} --copy-service
  pre_tasks:
    - name: Create openldap directories
      file:
        path: "{{ item.value }}"
        state: directory
        mode: 0700
      with_dict: "{{ openldap_directory }}"
  post_tasks:
    - name: Add iptables rules for OpenLDAP
      become: true
      iptables_raw:
        name: openldap_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ openldap_port_secure }} -j ACCEPT
      tags: iptables

    - name: Install requiered python LDAP module
      package:
        name: python-ldap
        state: present
      tags: dependencies

    - name: Wait for configuration database container to start
      wait_for:
        port: "{{ openldap_port_secure }}"

    - name: Add groups organizational unit
      ldap_entry:
        dn: "ou=groups,{{ openldap_base_DN }}"
        objectClass: organizationalUnit
        server_uri: "{{ openldap_server_uri }}"
        start_tls: false
        validate_certs: "{{ testing is undefined and openldap_validate_certs }}"
        bind_dn: "cn=admin,{{ openldap_base_DN }}"
        bind_pw: "{{ openldap_admin_password }}"
      tags:
        - ldap-setup

    - name: Add users organizational unit
      ldap_entry:
        dn: "ou=users,{{ openldap_base_DN }}"
        objectClass: organizationalUnit
        server_uri: "{{ openldap_server_uri }}"
        start_tls: false
        validate_certs: "{{ testing is undefined and openldap_validate_certs }}"
        bind_dn: "cn=admin,{{ openldap_base_DN }}"
        bind_pw: "{{ openldap_admin_password }}"
      tags:
        - ldap-setup

    - name: Add users group
      ldap_entry:
        dn: "cn=users,ou=groups,{{ openldap_base_DN }}"
        objectClass: posixGroup
        attributes:
          gidNumber: 2000
        server_uri: "{{ openldap_server_uri }}"
        start_tls: false
        validate_certs: "{{ testing is undefined and openldap_validate_certs }}"
        bind_dn: "cn=admin,{{ openldap_base_DN }}"
        bind_pw: "{{ openldap_admin_password }}"
      tags:
        - ldap-setup
  roles:
    - role: generic_docker_systemd
  tags: openldap

## phpLDAPadmin

- name: Deploy phpldapadmin in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    enable_db: false
    service_name: phpldapadmin
    docker_image: "{{ phpldapadmin_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -p {{ phpldapadmin_internal_web_port }}:80 \
      -e  PHPLDAPADMIN_LDAP_HOSTS="{{ phpldapadmin_ldap_hosts }}" \
      -e PHPLDAPADMIN_HTTPS="false" \
      -e PHPLDAPADMIN_LDAP_CLIENT_TLS_REQCERT="allow" \
      --network openldap \
      {{ docker_image }}
  roles:
    - role: generic_docker_systemd
  tags: phpldapadmin

- name: Get phpldapadmin subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ phpldapadmin_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: phpldapadmin

- name: Configure nginx proxy for phpldapadmin
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ phpldapadmin_domain }}"
    binded_port: "{{ phpldapadmin_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: phpldapadmin

## Prosody

- name: Get prosody subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ prosody_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service docker.prosody restart
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: prosody

- name: Get prosody subdomain Let's Encrypt certificate for MUC
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ prosody_domain_muc }}"
    letsencrypt_renew_hook: /usr/sbin/service docker.prosody restart
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
      when: prosody_enable_muc
  tags: prosody

- name: Get prosody subdomain Let's Encrypt certificate for http_upload
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ prosody_domain_upload }}"
    letsencrypt_renew_hook: /usr/sbin/service docker.prosody restart
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
      when: prosody_enable_http_upload
  tags: prosody

- name: Deploy prosody in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: prosody
    docker_image: "{{ prosody_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name {{ service_name }} \
      -v {{ prosody_directory.conf }}:/etc/prosody \
      -v {{ prosody_directory.data }}:/var/lib/prosody \
      -v {{ prosody_directory.modules_community }}:/usr/lib/prosody/modules-community \
      -v {{ prosody_directory.modules_custom }}:/usr/lib/prosody/modules-custom \
      -v {{ prosody_cert_path.privkey }}:/etc/prosody/certs/{{ prosody_domain }}.key:ro \
      -v {{ prosody_cert_path.cert }}:/etc/prosody/certs/{{ prosody_domain }}.crt:ro \
      -p {{ prosody_port_c2s }}:5222 \
      -p {{ prosody_port_s2s }}:5269 \
      {% if prosody_enable_http %}
      -p {{ prosody_port_internal_http }}:5280 \
      {% endif %}
      --user 1000:1000 \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create prosody directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ prosody_directory }}"
    - name: Configure prosody
      template:
        src: prosody-conf.j2
        dest: "{{ prosody_directory.conf }}/prosody.cfg.lua"
        force: "{{ override | default('no') }}"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0600
  post_tasks:
    - name: Register jabber users
      expect:
        command: "docker exec -it {{ service_name }} prosodyctl adduser {{ item.jid }}"
        timeout: 60
        creates: "{{ prosody_directory.data }}/{{ item.jid.split('@') | last | replace('.', '%2e') }}/accounts/{{ item.jid.split('@') | first }}.dat"
        responses:
          "Enter new password:": "{{ item.pass }}"
          "Retype new password:": "{{ item.pass }}"
      with_items: "{{ prosody_users }}"
      no_log: true
    - name: Add iptables rules for prosody
      iptables_raw:
        name: prosody_rules
        weight: 20
        rules: |
          {{ prosody_iptables_c2s_rule }}
          {{ prosody_iptables_s2s_rule }}
          {% if prosody_enable_http %}
          {{ prosody_iptables_https_rule }}
          {% endif %}
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: prosody

- name: Configure nginx proxy for prosody http_upload
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ prosody_domain_upload }}"
    binded_port: "{{ prosody_port_internal_http }}"
    external_port: "{{ prosody_port_external_https }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
      when: prosody_enable_http_upload
  tags: prosody

## Gitea

- name: Deploy gitea in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: gitea
    docker_image: "{{ gitea_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ gitea_directory.data }}":/data \
      -p "{{ gitea_ssh_port }}:22" -p "{{ gitea_internal_web_port }}:3000" \
      -e "USER_UID=1000" -e "USER_GID=1000" \
      --network "{{ gitea_network }}" \
      "{{ docker_image }}"
    docker_service_directory_db: "{{ gitea_directory.db }}"
    service_db_name: "{{ gitea_db_service_name }}"
    db_name: "{{ gitea_db_name }}"
    db_user: "{{ gitea_db_user }}"
    db_user_pass: "{{ gitea_db_user_pass }}"
  pre_tasks:
    - name: Create gitea directories 755
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0755
      with_items:
        - "{{ gitea_directory.data }}"
        - "{{ gitea_directory.conf }}"
        - "{{ gitea_directory.git_data }}"

    - name: Create gitea directories 700
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_items:
        - "{{ gitea_directory.db }}"
        - "{{ gitea_directory.ssh_data }}"

    - name: Configure gitea
      template:
        src: gitea-app.ini.j2
        dest: "{{ gitea_directory.data }}/gitea/conf/app.ini"
        force: "{{ override | default('no') }}"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0644
  post_tasks:
    - name: Add iptables rules for gitea
      become: true
      iptables_raw:
        name: gitea_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ gitea_ssh_port | default('2222') }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: gitea

- name: Get gitea subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ gitea_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: gitea

- name: Configure nginx proxy for gitea
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ gitea_domain }}"
    binded_port: "{{ gitea_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: gitea

## CodiMD

- name: Deploy codimd in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: codimd
    docker_image: "{{ codimd_docker_image }}"
    docker_db_image: "{{ codimd_db_image }}"
    create_network: true
    db_type: postgres
    docker_service_directory_db: "{{ codimd_directory.db }}"
    db_user_pass: "{{ codimd_db_user_pass }}"
    db_config_port: 5432
    db_name: "{{ codimd_db_name }}"
    db_user: "{{ codimd_db_user }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -p "{{ codimd_web_port }}:3000" \
      -e "USER_UID=1000" -e "USER_GID=1000" \
      -e "CMD_DOMAIN={{ codimd_domain }}" \
      -e "CMD_DB_URL=postgres://{{ codimd_db_user }}:{{ codimd_db_user_pass }}@{{ codimd_db_service_name }}:5432/{{ codimd_db_name }}" \
      -e "CMD_URL_ADDPORT=false" \
      {% if codimd_enable_ldap %}
      -e "CMD_LDAP_URL={{ codimd_ldap_url }}" \
      -e "CMD_LDAP_BINDDN={{ codimd_ldap_bind_dn }}" \
      -e "CMD_LDAP_BINDCREDENTIALS={{ codimd_ldap_bind_credentials }}" \
      -e "CMD_LDAP_SEARCHBASE={{ codimd_ldap_search_base }}" \
      -e "CMD_LDAP_SEARCHFILTER={{ codimd_ldap_search_filter }}" \
      -e "CMD_LDAP_SEARCHATTRIBUTES={{ codimd_ldap_search_attributes }}" \
      -e "CMD_LDAP_USERIDFIELD={{ codimd_ldap_user_field }}" \
      -e "CMD_LDAP_USERNAMEFIELD={{ codimd_ldap_user_name_field }}" \
      -e 'CMD_IMAGE_UPLOAD_TYPE=filesystem' \
      -e "CMD_LDAP_TLS_CA=/etc/ssl/certs/ca-certificates.crt" \
      -v "{{ ca_certs_path }}:/etc/ssl/certs/ca-certificates.crt:ro" \
      -v "{{ codimd_directory.uploads }}:/codimd/public/uploads/" \
      {% endif %}
      --network "{{ codimd_network_name }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create codimd directories
      file:
        path: "{{ item.value }}"
        state: directory
        mode: 0700
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
      with_dict: "{{ codimd_directory }}"
  roles:
    - role: generic_docker_systemd
  tags: codimd

- name: Get codimd subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ codimd_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: codimd

- name: Configure nginx proxy for codimd
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ codimd_domain }}"
    binded_port: "{{ codimd_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: codimd

## Drone

- name: Deploy drone in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    enable_db: false
    service_name: drone
    docker_image: "{{ drone_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ drone_directory.data }}":/data \
      -p "{{ drone_internal_web_port }}:80" \
      -e "USER_UID=1000" -e "USER_GID=1000" \
      -e "DRONE_GITEA_SERVER=https://{{ gitea_domain }}" \
      -e "DRONE_GITEA_CLIENT_ID={{ gitea_oauth_client_id }}" \
      -e "DRONE_GITEA_CLIENT_SECRET={{ gitea_oauth_client_secret }}" \
      -e "DRONE_RPC_SECRET={{ drone_rpc_scret }}" \
      -e "DRONE_GIT_ALWAYS_AUTH=false" \
      -e "DRONE_RUNNER_CAPACITY=2" \
      -e "DRONE_SERVER_HOST={{ drone_domain }}" \
      -e "DRONE_SERVER_PROTO=https" \
      -e "DRONE_TLS_AUTOCERT=false" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create drone directories
      file:
        path: "{{ drone_directory.data }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
  roles:
    - role: generic_docker_systemd
  tags: drone

- name: Get drone subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ drone_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: drone

- name: Configure nginx proxy for drone
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ drone_domain }}"
    binded_port: "{{ drone_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: drone

## Drone docker runner

- name: Deploy drone docker runner in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    enable_db: false
    service_name: drone-docker-runner
    docker_image: "{{ drone_docker_runner_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v /var/run/docker.sock:/var/run/docker.sock \
      -p "{{ drone_docker_runner_internal_web_port }}:3000" \
      -e "DRONE_RPC_PROTO=https" \
      -e "DRONE_RPC_HOST={{ drone_domain }}" \
      -e "DRONE_RPC_SECRET={{ drone_rpc_scret }}" \
      -e "DRONE_RUNNER_CAPACITY=2" \
      -e "DRONE_RUNNER_NAME={{ drone_runner_name }}" \
      "{{ docker_image }}"
  roles:
    - role: generic_docker_systemd
  tags: drone

## Drone exec runner

- name: Install drone exec runner
  hosts: all
  become: true
  gather_facts: false
  tasks:
    - name: Provisioning drone exec runner
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ user_uid_1000 }}"
        mode: 0755
      with_items:
        - "{{ drone_exec_runner_directory.config }}"
        - "{{ drone_exec_runner_directory.log }}"
    - name: Check if there is a drone exec runner installed
      stat:
        path: "{{ drone_exec_runner_script_path }}/drone-runner-exec"
      register: drone_exec_runner_script
    - name: Download install script drone exec runner
      get_url:
        url: "{{ drone_exec_runner_download }}"
        dest: "{{ drone_exec_runner_download_path }}"
      when:
        - not drone_exec_runner_script.stat.exists
    - name: Extract install script drone exec runner
      unarchive:
        src: "{{ drone_exec_runner_download_path }}"
        dest: "{{ drone_exec_runner_script_path }}"
        remote_src: yes
        owner: root
        group: root
        mode: 0755
      when:
        - not drone_exec_runner_script.stat.exists
    - name: Set drone exec runner config
      template:
        src: drone-exec-runner-config.j2
        dest: "{{ drone_exec_runner_path.config }}"
        owner: "{{ user_uid_1000 }}"
        group: "{{ user_uid_1000 }}"
        mode: 0755
      register: drone_exec_runner_config
    - name: Install new drone exec runner config
      become: true
      template:
        src: drone-exec-runner-service.j2
        dest: "/etc/systemd/system/{{ drone_exec_runner_service_name }}.service"
        owner: root
        group: root
      register: drone_exec_runner_service
    - name: Start drone exec runner service
      become: true
      systemd:
        name: "{{ drone_exec_runner_service_name }}"
        enabled: yes
        daemon_reload: yes
        state: started
      when: drone_exec_runner_config.changed or drone_exec_runner_service.changed
  tags: [ never, drone ]

## Drone for GitHub

- name: Deploy drone for github in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    enable_db: false
    service_name: drone_github
    docker_image: "{{ drone_github_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v /var/run/docker.sock:/var/run/docker.sock \
      -v "{{ drone_github_directory.data }}":/data \
      -p "{{ drone_github_internal_web_port }}:80" \
      -e "USER_UID=1000" -e "USER_GID=1000" \
      -e "DRONE_GITHUB_SERVER=https://github.com" \
      -e "DRONE_GITHUB_CLIENT_ID={{ drone_github_client_id }}" \
      -e "DRONE_GITHUB_CLIENT_SECRET={{ drone_github_client_secret }}" \
      -e "DRONE_RUNNER_CAPACITY=2" \
      -e "DRONE_SERVER_HOST={{ drone_github_domain }}" \
      -e "DRONE_SERVER_PROTO=https" \
      -e "DRONE_TLS_AUTOCERT=false" \
      --network "{{ gitea_network }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create drone_github directories
      file:
        path: "{{ drone_github_directory.data }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
  roles:
    - role: generic_docker_systemd
  tags: drone_github

- name: Get drone_github subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ drone_github_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: drone_github

- name: Configure nginx proxy for drone_github
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ drone_github_domain }}"
    binded_port: "{{ drone_github_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: drone_github

## Transmission

- name: Deploy transmission in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    enable_db: false
    service_name: transmission
    create_volume: false
    docker_image: "{{ transmission_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ transmission_directory.conf }}":/config \
      -v "{{ transmission_directory.downloads }}":/downloads \
      -v "{{ transmission_directory.watch }}":/watch \
      -e "PGID=1000" -e "PUID=1000" \
      -e "TZ={{ transmission_timezone }}" \
      -p "{{ transmission_internal_web_port }}:9091" \
      -p 51413:51413/tcp \
      -p 51413:51413/udp \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create transmission directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ transmission_directory }}"

    - name: Configure transmission
      template:
        src: transmission-settings.json.j2
        dest: "{{ transmission_directory.conf }}/settings.json"
        force: "{{ override | default('no') }}"
  post_tasks:
    - name: Add iptables rules for transmission
      iptables_raw:
        name: transmission_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ transmission_peer_port }} -j ACCEPT
          -A INPUT -p udp -m state --state NEW -m udp --dport {{ transmission_peer_port }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: transmission

- name: Get transmission subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ transmission_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: transmission

- name: Configure nginx proxy for transmission
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ transmission_domain }}"
    binded_port: "{{ transmission_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: transmission

## Transmission-OpenVPN

- name: Deploy transmission_openvpn in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    enable_db: false
    service_name: transmission_openvpn
    create_volume: false
    docker_image: "{{ transmission_openvpn_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ transmission_openvpn_directory.data }}":/data \
      -v /etc/localtime:/etc/localtime:ro \
      -e "PGID=1000" -e "PUID=1000" \
      -e CREATE_TUN_DEVICE=true \
      -e OPENVPN_PROVIDER={{ transmission_openvpn_vpn.provider }} \
      -e OPENVPN_CONFIG={{ transmission_openvpn_vpn.conf }} \
      -e OPENVPN_USERNAME={{ transmission_openvpn_vpn.user }} \
      -e OPENVPN_PASSWORD={{ transmission_openvpn_vpn.pass }} \
      -e TRANSMISSION_RPC_AUTHENTICATION_REQUIRED=true \
      -e TRANSMISSION_RPC_USERNAME={{ transmission_openvpn_rpc.user }} \
      -e TRANSMISSION_RPC_PASSWORD={{ transmission_openvpn_rpc.pass }} \
      -e WEBPROXY_ENABLED=false \
      {% for env_var in transmission_openvpn_extra_env -%}
      -e {{ env_var }} \
      {% endfor -%}
      -p {{ transmission_openvpn_internal_web_port }}:9091 \
      -p 51413:51413/tcp \
      -p 51413:51413/udp \
      --cap-add=NET_ADMIN \
      --dns {{ transmission_openvpn_dns }} \
      {{ docker_image }}
  pre_tasks:
    - name: Create transmission_openvpn directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ transmission_openvpn_directory }}"
  roles:
    - role: generic_docker_systemd
  tags: transmission_openvpn

- name: Get transmission_openvpn subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ transmission_openvpn_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: transmission_openvpn

- name: Configure nginx proxy for transmission_openvpn
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ transmission_openvpn_domain }}"
    binded_port: "{{ transmission_openvpn_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: transmission_openvpn

## Wallabag

- name: Deploy wallabag in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: wallabag
    docker_image: "{{ wallabag_docker_image }}"
    create_user_and_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -p "{{ wallabag_internal_web_port }}:80" \
      -v "{{ wallabag_directory.images }}":/var/www/wallabag/web/assets/images \
      --network "{{ service_name }}" \
      -e "MYSQL_ROOT_PASSWORD={{ db_pass }}" \
      -e "SYMFONY__ENV__DOMAIN_NAME=https://{{ wallabag_domain }}" \
      -e "SYMFONY__ENV__FOSUSER_CONFIRMATION=false" \
      -e "SYMFONY__ENV__DATABASE_DRIVER=pdo_mysql" \
      -e "SYMFONY__ENV__DATABASE_HOST={{ service_db_name }}" \
      -e "SYMFONY__ENV__DATABASE_PORT=3306" \
      -e "SYMFONY__ENV__DATABASE_NAME={{ wallabag_db_name }}" \
      -e "SYMFONY__ENV__DATABASE_USER={{ wallabag_db_user }}" \
      -e "SYMFONY__ENV__DATABASE_PASSWORD={{ wallabag_db_user_pass }}" \
      "{{ docker_image }}"
    docker_service_directory_db: "{{ wallabag_directory.db }}"
    service_db_name: "{{ wallabag_db_service_name }}"
    db_name: "{{ wallabag_db_name }}"
    db_user: "{{ wallabag_db_user }}"
    db_user_pass: "{{ wallabag_db_user_pass }}"
  pre_tasks:
    - name: "Create wallabag directories nobody:nogroup"
      file:
        path: "{{ wallabag_directory.images }}"
        state: directory
        owner: nobody
        group: nogroup
        mode: 0700
    - name: Create wallabag directories 700
      file:
        path: "{{ wallabag_directory.db }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
  roles:
    - role: generic_docker_systemd
  tags: wallabag

- name: Get wallabag subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ wallabag_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: wallabag

- name: Configure nginx proxy for wallabag
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ wallabag_domain }}"
    binded_port: "{{ wallabag_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: wallabag

## Selfoss

#  TODO: configuration template <06-07-18, m0wer>
#  TODO: external db <06-07-18, m0wer>

#
# - name: Prepare selfoss deployment
#   hosts: all
#   tasks:
#     - name: Create selfoss data directory
#       file:
#         path: "{{ selfoss_path_data }}"
#         state: directory
#         owner: "{{ user_uid_1000 }}"
#         group: "{{ group_gid_1000 }}"
#         mode: 0700
#   tags: selfoss
#
# - name: Deploy selfoss in docker
#   hosts: all
#   vars:
#     create_volume: false
#     service_name: selfoss
#     docker_image: "{{ selfoss_docker_image }}"
#     enable_db: false
#     docker_command: |
#       /usr/bin/docker run --rm --name "{{ service_name }}" \
#       -e GID=0 -e UID=0 \
#       -p "{{ selfoss_internal_web_port }}:8888" \
#       -v "{{ selfoss_path_data }}":/var/www/html/data \
#       "{{ docker_image }}"
#   roles:
#     - role: generic_docker_systemd
#   tags: selfoss
#
# - name: Get selfoss subdomain Let's Encrypt certificate
#   hosts: all
#   vars:
#     domain: "{{ selfoss_domain }}"
#     letsencrypt_renew_hook: /usr/sbin/service nginx reload
#   roles:
#     - role: letsencrypt-request
#      tags: letsecrypt_request
#   tags: selfoss
#
# - name: Configure nginx proxy for selfoss
#   hosts: all
#   vars:
#     domain: "{{ selfoss_domain }}"
#     binded_port: "{{ selfoss_internal_web_port }}"
#   roles:
#     - role: add_nginx_proxy_conf
#      tags: proxy
#   tags: selfoss

## Syncthing

- name: Deploy syncthing in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: syncthing
    docker_image: "{{ syncthing_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ syncthing_directory.conf }}":/var/syncthing/config \
      -v "{{ syncthing_directory.data }}":/var/syncthing \
      -p "{{ syncthing_internal_web_port }}:8384" \
      -p "{{ syncthing_listening_port }}:22000" \
      -p "{{ syncthing_discovery_port }}:21027/udp" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create syncthing directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ syncthing_directory }}"
  post_tasks:
    - name: Add iptables rules for syncthing
      iptables_raw:
        name: syncthing_rules
        weight: 20
        rules: |
          -A INPUT -p udp -m state --state NEW -m udp --dport {{ syncthing_discovery_port }} -j ACCEPT
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ syncthing_listening_port }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: syncthing

- name: Get syncthing subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ syncthing_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: syncthing

- name: Configure nginx proxy for syncthing
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ syncthing_domain }}"
    binded_port: "{{ syncthing_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: syncthing

## OpenVPN

- name: Deploy openvpn in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: openvpn
    docker_image: "{{ openvpn_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ openvpn_directory.conf }}":/etc/openvpn \
      --cap-add=NET_ADMIN \
      -p "{{ openvpn_port }}:1194/{{ openvpn_protocol }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create openvpn directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ openvpn_directory }}"
      notify: Configure openvpn container
  post_tasks:
    - name: Add iptables rules for openvpn
      iptables_raw:
        name: openvpn_rules
        weight: 20
        rules: |
          {{ openvpn_iptables_p2p_rule }}
      tags: iptables
  handlers:
    - name: Configure openvpn container
      command: "{{ openvpn_confiure_docker_command }}"
      notify: Create openvpn CA
      #  docker_container:
      #    image: "{{ openvpn_docker_image }}"
      #    name: openvpn-conf
      #    cleanup: true
      #    command: "ovpn_genconfig -u {{ openvpn_protocol }}://{{ openvpn_domain }}"
    - name: Create openvpn CA
      expect:
        command: "{{ openvpn_create_ca_command }}"
        timeout: 600
        responses:
          "Enter New CA Key Passphrase": "{{ openvpn_ca_pass }}"
          "Re-Enter New CA Key Passphrase": "{{ openvpn_ca_pass }}"
          "Common Name": "{{ openvpn_ca_CN }}"
          "Enter pass phrase for": "{{ openvpn_ca_pass }}"
  roles:
    - role: generic_docker_systemd
  tags: openvpn

## Radicale

- name: Deploy radicale in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: radicale
    docker_image: "{{ radicale_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -e UID=1000 -e GID=1000 \
      -p "127.0.0.1:5232:{{ radicale_internal_web_port }}" \
      --init \
      --pids-limit 50 \
      --security-opt="no-new-privileges:true" \
      --health-cmd="curl --fail http://localhost:5232 || exit 1" \
      --health-interval=30s \
      --health-retries=3 \
      -v "{{ radicale_directory.data }}":/data \
      -v "{{ radicale_directory.etc }}":/etc/radicale \
      -v "{{ radicale_directory.conf }}":/config:ro \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create radicale directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ radicale_directory }}"

    - name: Copy radicale configuration template
      template:
        src: radicale-config.j2
        dest: "{{ radicale_directory.conf }}/config"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700

    - name: Add radicale login credentiasl
      lineinfile:
        path: "{{ radicale_directory.etc }}/users"
        line: "{{ radicale_user }}:{{ radicale_pass }}"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
        create: true
  roles:
    - role: generic_docker_systemd
  tags: radicale

- name: Get radicale subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ radicale_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: radicale

- name: Configure nginx proxy for radicale
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ radicale_domain }}"
    binded_port: "{{ radicale_internal_web_port }}"
    proxy_conf: |
      proxy_pass        http://127.0.0.1:{{ binded_port }};
      proxy_set_header  X-Script-Name /;
      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_pass_header Authorization;
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: radicale

## taskd

- name: Deploy taskd in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    enable_db: false
    service_name: taskd
    docker_image: "{{ taskd_docker_image }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ taskd_directory.data }}":/var/taskd \
      -p "{{ taskd_port }}:53589" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create taskd directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ taskd_directory }}"
  post_tasks:
    - name: Add iptables rules for taskd
      iptables_raw:
        name: taskd_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ taskd_port | default('53589') }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: taskd

## Nextcloud

- name: Deploy nextcloud in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: nextcloud
    docker_image: "{{ nextcloud_docker_image }}"
    create_volume: false
    docker_service_directory_db: "{{ nextcloud_directory.db }}"
    service_db_name: "{{ nextcloud_db_service_name }}"
    db_name: "{{ nextcloud_db_name }}"
    db_user: "{{ nextcloud_db_user }}"
    db_user_pass: "{{ nextcloud_db_user_pass }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v "{{ nextcloud_directory.data }}":/var/www/html \
      -p "{{ nextcloud_internal_web_port }}:80" \
      -e "MYSQL_HOST={{ service_db_name }}" \
      -e "MYSQL_DATABASE={{ db_name }}" \
      -e "MYSQL_USER={{ db_user }}" \
      -e "MYSQL_PASSWORD={{ db_user_pass }}" \
      --network "{{ service_name }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create nextcloud directories 750 uid 33
      become: true
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ user_uid_33 }}"
        group: 0
        mode: 0750
      with_items:
        - "{{ nextcloud_directory.data }}"
    - name: Create nextcloud directories 700
      become: true
      file:
        path: "{{ item }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_items:
        - "{{ nextcloud_directory.db }}"
  roles:
    - role: generic_docker_systemd
  tags: nextcloud

- name: Get nextcloud subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ nextcloud_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: nextcloud

- name: Configure nginx proxy for nextcloud
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ nextcloud_domain }}"
    binded_port: "{{ nextcloud_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: nextcloud

## Taiga

- name: Deploy taiga in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: taiga
    docker_image: "{{ taiga_docker_image }}"
    docker_db_image: "{{ taiga_db_image }}"
    create_network: true
    create_volume: false
    db_type: postgres
    docker_service_directory_db: "{{ taiga_directory.db }}"
    db_user_pass: "{{ taiga_db_user_pass }}"
    db_config_port: 5432
    db_name: "{{ taiga_db_name }}"
    db_user: "{{ taiga_db_user }}"
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -p "{{ taiga_internal_web_port }}:80" \
      -e "TAIGA_HOSTNAME={{ taiga_domain }}" \
      -e 'TAIGA_SSL=true' \
      -e "TAIGA_SECRET_KEY={{ taiga_secret_key }}" \
      -e 'TAIGA_DB_HOST=taiga-db' \
      -e "TAIGA_DB_NAME={{ db_name }}" \
      -e "TAIGA_DB_USER={{ db_user }}" \
      -e "TAIGA_DB_PASSWORD={{ db_user_pass }}" \
      -e "TAIGA_DEFAULT_FROM_EMAIL={{ taiga_default_from_email }}" \
      -e "TAIGA_EMAIL_BACKEND={{ taiga_email_backend }}" \
      -e "TAIGA_EMAIL_USE_TLS={{ taiga_email_use_tls }}" \
      -e "TAIGA_EMAIL_USE_SSL={{ taiga_email_use_ssl }}" \
      -e "TAIGA_EMAIL_HOST={{ taiga_email_host }}" \
      -e "TAIGA_EMAIL_PORT={{ taiga_email_port }}" \
      -e "TAIGA_EMAIL_USER={{ taiga_email_user }}" \
      -e "TAIGA_EMAIL_PASSWORD={{ taiga_email_password }}" \
      {% if taiga_enable_ldap %}
      -e 'LDAP_ENABLE=true' \
      -e "LDAP_SERVER={{ taiga_ldap_server }}" \
      -e "LDAP_PORT={{ taiga_ldap_port }}" \
      -e "LDAP_BIND_DN={{ taiga_ldap_bind_dn }}" \
      -e "LDAP_BIND_PASSWORD={{ taiga_ldap_bind_credentials }}" \
      -e "LDAP_SEARCH_BASE={{ taiga_ldap_search_base }}" \
      -e "LDAP_SEARCH_PROPERTY={{ taiga_ldap_search_property }}" \
      -e "LDAP_EMAIL_PROPERTY={{ taiga_ldap_email_attribute }}" \
      -e "LDAP_FULL_NAME_PROPERTY={{ taiga_ldap_full_name_attribute }}" \
      -e "TAIGA_BACKEND_WEBHOOKS_ENABLED={{ taiga_backend_webhooks_enabled }}" \
      -v "{{ taiga_directory.media }}:/taiga.io/taiga-back/media" \
      {% endif %}
      --network "{{ service_name }}" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create taiga directories
      file:
        path: "{{ item.value }}"
        state: directory
        mode: 0700
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
      with_dict: "{{ taiga_directory }}"
  roles:
    - role: generic_docker_systemd
  tags: taiga

- name: Get taiga subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ taiga_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: taiga

- name: Configure nginx proxy for taiga
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ taiga_domain }}"
    binded_port: "{{ taiga_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: taiga

## NFS

- name: Deploy nfs in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    service_name: nfs
    docker_image: "{{ nfs_docker_image }}"
    enable_db: false
    create_network: false
    create_volume: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      --cap-add SYS_ADMIN \
      -v "{{ nfs_directory.conf }}/exports":/etc/exports:ro \
      {{ nfs_export_volumes }}-p "{{ nfs_port | default('2049') }}:2049" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create nfs directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ nfs_directory }}"

    - name: Create nfs user mount directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ nfs_user_mounts }}"
      when: nfs_user_mounts is defined

    - name: Create nfs configuration file
      file:
        path: "{{ nfs_directory.conf }}/exports"
        state: touch
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
        modification_time: "preserve"
        access_time: "preserve"

    - name: Configure nfs
      blockinfile:
        block: "{{ nfs_exports_conf }}"
        path: "{{ nfs_directory.conf }}/exports"

    - name: Load kernel modules for nfs
      become: true
      modprobe:
        name: "{{ item }}"
        state: present
      with_items:
        - nfs
        - nfsd

    - name: Load kernel modules for nfs at boot
      become: true
      lineinfile:
        path: /etc/modules
        state: present
        line: "{{ item }}"
      with_items:
        - nfs
        - nfsd
  post_tasks:
    - name: Add iptables rules for nfs
      become: true
      iptables_raw:
        name: nfs_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ nfs_port | default('2049') }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: nfs

## BIND DNS Server

- name: Deploy bind_dns_server in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    enable_db: false
    create_network: true
    service_name: bind_dns_server
    docker_image: "{{ bind_dns_server_docker_image }}"
    container_certs_path: /container/service/slapd/assets/certs
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -v {{ bind_dns_server_directory.data }}:/data \
      -p {{ bind_dns_server_port }}:53/tcp \
      -p {{ bind_dns_server_port }}:53/udp \
      -e WEBMIN_ENABLED=false \
      --network {{ service_name }} \
      {{ docker_image }}
  pre_tasks:
    - name: Create bind_dns_server directories
      file:
        path: "{{ item.value }}"
        owner: "{{ user_uid_101 }}"
        state: directory
        mode: 0700
      with_dict: "{{ bind_dns_server_directory }}"
  post_tasks:
    - name: Add iptables rules for BIND DNS server
      become: true
      iptables_raw:
        name: bind_dns_server_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ bind_dns_server_port }} -j ACCEPT
          -A INPUT -p udp -m state --state NEW -m udp --dport {{ bind_dns_server_port }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: bind_dns_server

## Murmur

- name: Get murmur subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ murmur_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service docker.murmur.service restart
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: murmur

- name: Deploy murmur in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: murmur
    docker_image: "{{ murmur_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      -e 'PUID=1000' -e 'PGID=1000' \
      -e 'RUN_CHOWN=false' \
      -e "CERTDIR=/etc/letsencrypt/live/{{ murmur_domain }}" \
      -v "{{ murmur_directory.conf }}":/opt/murmur/config \
      -v "{{ murmur_directory.data }}":/opt/murmur/data \
      -v "{{ murmur_directory.log }}":/opt/murmur/log \
      -v '/etc/localtime:/etc/localtime:ro' \
      -v /etc/letsencrypt/live/{{ murmur_domain }}:/etc/letsencrypt/live/{{ murmur_domain }}/:ro \
      -v /etc/letsencrypt/archive/{{ murmur_domain }}:/etc/letsencrypt/archive/{{ murmur_domain }}/:ro \
      -p "{{ murmur_port }}:64738/tcp" \
      -p "{{ murmur_port }}:64738/udp" \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create murmur directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ murmur_directory }}"
  post_tasks:
    - name: Add iptables rules for murmur
      iptables_raw:
        name: murmur_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ murmur_port }} -j ACCEPT
          -A INPUT -p udp -m state --state NEW -m udp --dport {{ murmur_port }} -j ACCEPT
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: murmur

## InfluxDB

- name: Deploy influxdb in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: influxdb
    docker_image: "{{ influxdb_docker_image }}"
    enable_db: false
    create_network: true
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      --user 1000:1000 \
      -v "{{ influxdb_directory.data }}":/var/lib/influxdb \
      -p "{{ influxdb_port }}:8086" \
      --network {{ service_name }} \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create influxdb directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ influxdb_directory }}"
    - name: Check if influxdb is already configured
      stat:
        path: "{{ influxdb_directory.data }}/data"
      register: database_influxdb_conf
    - name: Configure influxdb
      docker_container:
        image: "{{ influxdb_docker_image }}"
        name: influxdb-conf
        cleanup: true
        user: 1000:1000
        volumes:
          - "{{ influxdb_directory.data }}:/var/lib/influxdb"
        env:
          INFLUXDB_DB: "{{ influxdb_db }}"
          INFLUXDB_ADMIN_USER: "{{ influxdb_admin_user }}"
          INFLUXDB_ADMIN_PASSWORD: "{{ influxdb_admin_password }}"
          INFLUXDB_USER: "{{ influxdb_user }}"
          INFLUXDB_USER_PASSWORD: "{{ influxdb_user_password }}"
        ports:
          - "{{ influxdb_port }}:8086"
      when: not database_influxdb_conf.stat.exists
    - name: Wait for configuration container to finish setting up
      wait_for:
        port: "{{ influxdb_port }}"
      when: not database_influxdb_conf.stat.exists
    - name: Remove configuration container
      docker_container:
        name: influxdb-conf
        state: absent
      when: not database_influxdb_conf.stat.exists
  post_tasks:
    - name: Add iptables rules for influxdb
      iptables_raw:
        name: influxdb_rules
        weight: 20
        rules: |
          -A INPUT -p tcp -m state --state NEW -m tcp --dport {{ influxdb_port }} -j ACCEPT
      when: influxdb_open_port
      tags: iptables
  roles:
    - role: generic_docker_systemd
  tags: influxdb

## Grafana

- name: Deploy grafana in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: grafana
    docker_image: "{{ grafana_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      --user 1000:1000 \
      -v "{{ grafana_directory.conf }}":/etc/grafana \
      -v "{{ grafana_directory.data }}":/var/lib/grafana \
      -p "{{ grafana_internal_web_port }}:3000" \
      {% if grafana_network is defined %}
      --network {{ service_name }} \
      {% endif %}
      "{{ docker_image }}"
  pre_tasks:
    - name: Create grafana directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ grafana_directory }}"
    - name: Configure grafana
      template:
        src: grafana.ini.j2
        dest: "{{ grafana_directory.conf }}/grafana.ini"
        force: "{{ override | default('no') }}"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0600
  roles:
    - role: generic_docker_systemd
  tags: grafana

- name: Get grafana subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ grafana_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: grafana

- name: Configure nginx proxy for grafana
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ grafana_domain }}"
    binded_port: "{{ grafana_internal_web_port }}"
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: grafana

## Home Assistant

- name: Deploy home_assistant in docker
  hosts: all
  become: true
  gather_facts: false
  vars:
    create_volume: false
    service_name: home_assistant
    docker_image: "{{ home_assistant_docker_image }}"
    enable_db: false
    docker_command: |
      /usr/bin/docker run --rm --name "{{ service_name }}" \
      --user 1000:1000 \
      -v "{{ home_assistant_directory.conf }}":/config \
      -v /etc/localtime:/etc/localtime:ro \
      --net=host \
      "{{ docker_image }}"
  pre_tasks:
    - name: Create home_assistant directories
      file:
        path: "{{ item.value }}"
        state: directory
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0700
      with_dict: "{{ home_assistant_directory }}"
    - name: Touch home_assistant extra configuration files
      file:
        path: "{{ home_assistant_directory.conf }}/{{ item }}"
        state: touch
        modification_time: preserve
        access_time: preserve
      with_items:
        - groups.yaml
        - scripts.yaml
    - name: Copy empty automations file
      copy:
        src: home_assistant_automations.yaml
        dest: "{{ home_assistant_directory.conf }}/automations.yaml"
        force: "{{ override | default('no') }}"
    - name: Configure home_assistant
      template:
        src: home_assistant.yaml.j2
        dest: "{{ home_assistant_directory.conf }}/configuration.yaml"
        force: "{{ override | default('no') }}"
        owner: "{{ user_uid_1000 }}"
        group: "{{ group_gid_1000 }}"
        mode: 0600
  roles:
    - role: generic_docker_systemd
  tags: home_assistant

- name: Get home_assistant subdomain Let's Encrypt certificate
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ home_assistant_domain }}"
    letsencrypt_renew_hook: /usr/sbin/service nginx reload
  roles:
    - role: letsencrypt-request
      tags: letsecrypt_request
  tags: home_assistant

- name: Configure nginx proxy for home_assistant
  hosts: all
  become: true
  gather_facts: false
  vars:
    domain: "{{ home_assistant_domain }}"
    binded_port: "{{ home_assistant_internal_web_port }}"
    proxy_conf: |
      proxy_pass        http://127.0.0.1:{{ binded_port }};
      proxy_set_header  X-Script-Name /;
      proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_pass_header Authorization;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
  roles:
    - role: add_nginx_proxy_conf
      tags: proxy
  tags: home_assistant
